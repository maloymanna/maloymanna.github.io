<div class="tts-container" style="padding-bottom: 2em; margin-bottom: 2em; border-bottom: 1px solid #eee;">
  <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
    <button id="tts-button" class="pure-button tts-button" style="display: flex; align-items: center; gap: 8px; font-family: inherit; font-weight: 600; background: #1f8dd6; color: white; border-radius: 4px; padding: 0.5em 1.5em;">
      <span id="tts-icon">ğŸ”Š</span>
      <span id="tts-text">Listen to this article</span>
    </button>
    <button id="tts-debug-toggle" class="pure-button" style="padding: 4px 8px; font-size: 0.7em; background: #666; color: white;">ğŸ› Debug</button>
    <div id="tts-status" style="font-size: 0.9em; color: #777; font-style: italic;">Ready</div>
  </div>

  <div id="tts-debug-panel" style="display: none; margin-top: 15px; padding: 10px; background: #222; color: #0f0; font-family: monospace; font-size: 11px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
      <span>DEBUG LOG (Android Fix Active)</span>
      <button id="tts-debug-clear" style="background: #444; color: #fff; border: none; cursor: pointer;">Clear</button>
    </div>
    <div id="tts-debug-content"></div>
  </div>
</div>

<script>
(function() {
  const config = { speed: 1.0, pitch: 1.0, volume: 1.0 };
  let isPaused = false;
  let isPlaying = false;
  let allVoices = [];
  let selectedVoice = null;
  let textChunks = [];
  let currentChunkIndex = 0;
  
  // Detection for the Android Resume bug
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isChrome = /Chrome/i.test(navigator.userAgent);

  window._ttsUtterance = null;
  let button, buttonIcon, buttonText, statusDiv, debugContent, debugPanel;

  function debugLog(msg) {
    console.log("[TTS DEBUG]", msg);
    if (debugContent) {
      const entry = document.createElement('div');
      entry.textContent = `> ${new Date().toLocaleTimeString()}: ${msg}`;
      debugContent.appendChild(entry);
      debugContent.scrollTop = debugContent.scrollHeight;
    }
  }

  function setStatus(msg, isErr = false) {
    if (statusDiv) {
      statusDiv.textContent = msg;
      statusDiv.style.color = isErr ? "#b91d47" : "#777";
    }
  }

  function updateUI(state) {
    if (!button) return;
    if (state === 'playing') {
      buttonIcon.textContent = 'â¸ï¸'; buttonText.textContent = 'Pause'; button.style.background = '#e91e63';
    } else if (state === 'paused') {
      buttonIcon.textContent = 'â–¶ï¸'; buttonText.textContent = 'Resume'; button.style.background = '#1f8dd6';
    } else {
      buttonIcon.textContent = 'ğŸ”Š'; buttonText.textContent = 'Listen to this article'; button.style.background = '#1f8dd6';
    }
  }

  function loadVoices() {
    return new Promise((resolve) => {
      const synth = window.speechSynthesis;
      const trySelect = () => {
        allVoices = synth.getVoices();
        if (allVoices.length > 0) {
          const voiceTiers = [
            ['Microsoft Jenny', 'Microsoft Aria', 'Microsoft Emma'],
            ['Google UK English Female', 'Google US English'],
            ['Samantha', 'Alex'],
            ['Microsoft', 'Google']
          ];
          for (const tier of voiceTiers) {
            for (const name of tier) {
              let match = allVoices.find(v => v.name.toLowerCase().includes(name.toLowerCase()));
              if (match) { selectedVoice = match; debugLog(`Voice: ${match.name}`); resolve(); return; }
            }
          }
          selectedVoice = allVoices[0];
          resolve();
        }
      };
      if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = trySelect;
      trySelect();
    });
  }

  function getCleanArticleText() {
    const selectors = ['.post-content', '.content', '#main', 'article'];
    let content = null;
    for (const s of selectors) {
      const el = document.querySelector(s);
      if (el) { content = el; break; }
    }
    if (!content) content = document.body;
    const clone = content.cloneNode(true);
    const exclude = ['script', 'style', 'nav', 'header', 'footer', '.tts-container', 'aside', '.sidebar', '#menu'];
    exclude.forEach(s => clone.querySelectorAll(s).forEach(el => el.remove()));
    return (clone.innerText || clone.textContent).replace(/\s+/g, ' ').trim();
  }

  function speakChunk() {
    if (currentChunkIndex >= textChunks.length) {
      isPlaying = false; updateUI('default'); setStatus('Finished');
      return;
    }

    const synth = window.speechSynthesis;
    // Always create a fresh utterance instance
    window._ttsUtterance = new SpeechSynthesisUtterance(textChunks[currentChunkIndex]);
    window._ttsUtterance.voice = selectedVoice;
    window._ttsUtterance.rate = config.speed;
    
    window._ttsUtterance.onstart = () => {
      debugLog(`Started chunk ${currentChunkIndex}`);
      isPlaying = true; 
      isPaused = false;
      updateUI('playing'); 
      setStatus('Reading...');
    };

    window._ttsUtterance.onend = () => {
      debugLog(`Ended chunk ${currentChunkIndex}`);
      if (!isPaused) {
        currentChunkIndex++;
        speakChunk();
      }
    };

    window._ttsUtterance.onerror = (e) => {
      debugLog(`Error in chunk ${currentChunkIndex}: ${e.error}`);
      // If error is 'interrupted' on Android, it usually means we called cancel()
      if (e.error !== 'interrupted') {
        isPlaying = false;
        updateUI('default');
      }
    };

    synth.speak(window._ttsUtterance);
    
    // Essential for Linux/Android Chrome: ensure engine isn't in 'pending'
    if (synth.paused) synth.resume();
  }

  async function toggleSpeech() {
    const synth = window.speechSynthesis;

    if (isPlaying && !isPaused) {
      debugLog("Action: Pause");
      synth.pause();
      isPaused = true;
      updateUI('paused');
      setStatus('Paused');
      return;
    }

    if (isPaused) {
      debugLog("Action: Resume requested");
      
      if (isAndroid && isChrome) {
        debugLog("Android Chrome detected: Using 'Re-speak' Resume strategy");
        // Android fix: Resume often stalls. 
        // We cancel the "paused" state and restart the current chunk from the beginning.
        synth.cancel();
        setTimeout(() => {
          speakChunk();
        }, 50);
      } else {
        // Standard resume for Linux/Edge/iOS
        isPaused = false;
        synth.resume();
        // Fallback: If standard resume fails to report speaking after 400ms
        setTimeout(() => {
          if (isPaused === false && (!synth.speaking || synth.paused)) {
            debugLog("Standard resume stalled, forcing re-speak...");
            synth.cancel();
            speakChunk();
          }
        }, 400);
      }
      
      updateUI('playing');
      setStatus('Reading...');
      return;
    }

    debugLog("Action: New Session");
    synth.cancel();
    setTimeout(async () => {
      await loadVoices();
      const rawText = getCleanArticleText();
      // Improved chunking: split by punctuation but filter empty strings
      textChunks = rawText.match(/[^\.!\?]+[\.!\?]+/g) || [rawText];
      textChunks = textChunks.map(t => t.trim()).filter(t => t.length > 0);
      
      currentChunkIndex = 0;
      isPaused = false;
      if (textChunks.length > 0) speakChunk();
      else setStatus('No text found', true);
    }, 150);
  }

  function init() {
    button = document.getElementById('tts-button');
    buttonIcon = document.getElementById('tts-icon');
    buttonText = document.getElementById('tts-text');
    statusDiv = document.getElementById('tts-status');
    debugPanel = document.getElementById('tts-debug-panel');
    debugContent = document.getElementById('tts-debug-content');

    if (!button) return;

    button.addEventListener('click', toggleSpeech);
    document.getElementById('tts-debug-toggle').addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
    document.getElementById('tts-debug-clear').addEventListener('click', () => { debugContent.innerHTML = ''; });

    if ('speechSynthesis' in window) {
      loadVoices().then(() => setStatus('Ready'));
    } else {
      setStatus('Not supported', true);
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
  
  window.addEventListener('beforeunload', () => window.speechSynthesis.cancel());
})();
</script>

<style>
.tts-button { transition: background 0.2s ease, transform 0.1s ease; border: none; }
.tts-button:hover { filter: brightness(110%); }
.tts-button:active { transform: translateY(1px); }
@media (prefers-color-scheme: dark) {
  .tts-container { border-bottom-color: #333 !important; }
  #tts-status { color: #999 !important; }
}
</style>