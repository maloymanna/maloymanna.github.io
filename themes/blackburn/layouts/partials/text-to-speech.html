<div class="tts-container" style="padding-bottom: 2em; margin-bottom: 2em; border-bottom: 1px solid #eee;">
  <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
    <button id="tts-button" class="pure-button tts-button" style="display: flex; align-items: center; gap: 8px; font-family: inherit; font-weight: 600; background: #1f8dd6; color: white; border-radius: 4px; padding: 0.5em 1.5em;">
      <span id="tts-icon">ğŸ”Š</span>
      <span id="tts-text">Listen to this article</span>
    </button>
    <button id="tts-debug-toggle" class="pure-button" style="padding: 4px 8px; font-size: 0.7em; background: #666; color: white;">ğŸ› Debug</button>
    <div id="tts-status" style="font-size: 0.9em; color: #777; font-style: italic;">Ready</div>
  </div>

  <div id="tts-debug-panel" style="display: none; margin-top: 15px; padding: 10px; background: #222; color: #0f0; font-family: monospace; font-size: 11px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
      <span>DEBUG LOG (Android Ticker Active)</span>
      <button id="tts-debug-clear" style="background: #444; color: #fff; border: none; cursor: pointer;">Clear</button>
    </div>
    <div id="tts-debug-content"></div>
  </div>
</div>

<script>
(function() {
  const config = { speed: 1.0, pitch: 1.0, volume: 1.0 };
  let isPaused = false;
  let isPlaying = false;
  let allVoices = [];
  let selectedVoice = null;
  let textChunks = [];
  let currentChunkIndex = 0;
  
  // Tracking progress for the Android Resume bug
  let lastKnownCharIndex = 0;
  let tickerInterval = null;
  const ESTIMATED_CHARS_PER_SEC = 15; // Average speed for Android OS voices

  const isAndroid = /Android/i.test(navigator.userAgent);
  const isChrome = /Chrome/i.test(navigator.userAgent);

  window._ttsUtterance = null;
  let button, buttonIcon, buttonText, statusDiv, debugContent, debugPanel;

  function debugLog(msg) {
    console.log("[TTS DEBUG]", msg);
    if (debugContent) {
      const entry = document.createElement('div');
      entry.textContent = `> ${new Date().toLocaleTimeString()}: ${msg}`;
      debugContent.appendChild(entry);
      debugContent.scrollTop = debugContent.scrollHeight;
    }
  }

  function setStatus(msg, isErr = false) {
    if (statusDiv) {
      statusDiv.textContent = msg;
      statusDiv.style.color = isErr ? "#b91d47" : "#777";
    }
  }

  function updateUI(state) {
    if (!button) return;
    if (state === 'playing') {
      buttonIcon.textContent = 'â¸ï¸'; buttonText.textContent = 'Pause'; button.style.background = '#e91e63';
    } else if (state === 'paused') {
      buttonIcon.textContent = 'â–¶ï¸'; buttonText.textContent = 'Resume'; button.style.background = '#1f8dd6';
    } else {
      buttonIcon.textContent = 'ğŸ”Š'; buttonText.textContent = 'Listen to this article'; button.style.background = '#1f8dd6';
    }
  }

  function loadVoices() {
    return new Promise((resolve) => {
      const synth = window.speechSynthesis;
      const trySelect = () => {
        allVoices = synth.getVoices();
        if (allVoices.length > 0) {
          // Tiered priority: Edge (if present) -> Chrome/Google -> System default
          const voiceTiers = [
            ['Microsoft Jenny', 'Microsoft Aria'],
            ['Google UK English', 'Google US English', 'Google English'],
            ['en-US', 'en-GB'],
            ['default']
          ];
          for (const tier of voiceTiers) {
            for (const name of tier) {
              let match = allVoices.find(v => v.name.includes(name) || v.lang.includes(name));
              if (match) { selectedVoice = match; debugLog(`Voice Selected: ${match.name}`); resolve(); return; }
            }
          }
          selectedVoice = allVoices[0];
          resolve();
        }
      };
      if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = trySelect;
      trySelect();
    });
  }

  function getCleanArticleText() {
    const selectors = ['.post-content', '.content', '#main', 'article'];
    let content = null;
    for (const s of selectors) {
      const el = document.querySelector(s);
      if (el) { content = el; break; }
    }
    if (!content) content = document.body;
    const clone = content.cloneNode(true);
    const exclude = ['script', 'style', 'nav', 'header', 'footer', '.tts-container', 'aside', '.sidebar', '#menu'];
    exclude.forEach(s => clone.querySelectorAll(s).forEach(el => el.remove()));
    return (clone.innerText || clone.textContent).replace(/\s+/g, ' ').trim();
  }

  function startTicker() {
    if (tickerInterval) clearInterval(tickerInterval);
    // Every 200ms, estimate how many characters have been read
    tickerInterval = setInterval(() => {
      if (!window.speechSynthesis.paused && isPlaying) {
        lastKnownCharIndex += (ESTIMATED_CHARS_PER_SEC * config.speed) * 0.2;
      }
    }, 200);
  }

  function stopTicker() {
    if (tickerInterval) clearInterval(tickerInterval);
  }

  function speakChunk(offset = 0) {
    if (currentChunkIndex >= textChunks.length) {
      isPlaying = false; updateUI('default'); setStatus('Finished');
      stopTicker();
      return;
    }

    const synth = window.speechSynthesis;
    const fullText = textChunks[currentChunkIndex];
    // Start from the estimated character position
    const textToSpeak = fullText.substring(Math.floor(offset));

    window._ttsUtterance = new SpeechSynthesisUtterance(textToSpeak);
    window._ttsUtterance.voice = selectedVoice;
    window._ttsUtterance.rate = config.speed;

    // Use onboundary if it works (Edge/Linux), but our ticker handles Android
    window._ttsUtterance.onboundary = (event) => {
      if (event.name === 'word') {
        lastKnownCharIndex = offset + event.charIndex;
      }
    };

    window._ttsUtterance.onstart = () => {
      debugLog(`Started chunk ${currentChunkIndex} at char ${Math.floor(offset)}`);
      isPlaying = true; isPaused = false;
      updateUI('playing'); setStatus('Reading...');
      startTicker();
    };

    window._ttsUtterance.onend = () => {
      if (!isPaused) {
        debugLog(`Finished chunk ${currentChunkIndex}`);
        currentChunkIndex++;
        lastKnownCharIndex = 0;
        speakChunk();
      }
    };

    window._ttsUtterance.onerror = (e) => {
      if (e.error !== 'interrupted') {
        debugLog(`Error: ${e.error}`);
        isPlaying = false; updateUI('default');
      }
    };

    synth.speak(window._ttsUtterance);
    if (synth.paused) synth.resume();
  }

  async function toggleSpeech() {
    const synth = window.speechSynthesis;

    if (isPlaying && !isPaused) {
      debugLog(`Action: Pause at estimated index ${Math.floor(lastKnownCharIndex)}`);
      synth.pause();
      isPaused = true;
      stopTicker();
      updateUI('paused');
      setStatus('Paused');
      return;
    }

    if (isPaused) {
      debugLog("Action: Resume requested");
      
      // Android Chrome OS Voice Fix: 
      // Forcefully cancel and restart from our tracked index because resume() is broken
      if (isAndroid && isChrome) {
        debugLog(`Android Fix: Re-starting from index ${Math.floor(lastKnownCharIndex)}`);
        synth.cancel();
        setTimeout(() => speakChunk(lastKnownCharIndex), 60);
      } else {
        isPaused = false;
        synth.resume();
        startTicker();
        // Native Resume Guard
        setTimeout(() => {
          if (isPaused === false && (!synth.speaking || synth.paused)) {
            debugLog("Resume stalled, forcing re-speak...");
            synth.cancel();
            speakChunk(lastKnownCharIndex);
          }
        }, 400);
      }
      
      updateUI('playing');
      setStatus('Reading...');
      return;
    }

    debugLog("Action: New Session");
    synth.cancel();
    setTimeout(async () => {
      await loadVoices();
      const rawText = getCleanArticleText();
      textChunks = rawText.match(/[^\.!\?]+[\.!\?]+/g) || [rawText];
      textChunks = textChunks.map(t => t.trim()).filter(t => t.length > 0);
      
      currentChunkIndex = 0;
      lastKnownCharIndex = 0;
      isPaused = false;
      if (textChunks.length > 0) speakChunk();
      else setStatus('No text found', true);
    }, 150);
  }

  function init() {
    button = document.getElementById('tts-button');
    buttonIcon = document.getElementById('tts-icon');
    buttonText = document.getElementById('tts-text');
    statusDiv = document.getElementById('tts-status');
    debugPanel = document.getElementById('tts-debug-panel');
    debugContent = document.getElementById('tts-debug-content');

    if (!button) return;

    button.addEventListener('click', toggleSpeech);
    document.getElementById('tts-debug-toggle').addEventListener('click', () => {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
    document.getElementById('tts-debug-clear').addEventListener('click', () => { debugContent.innerHTML = ''; });

    if ('speechSynthesis' in window) {
      loadVoices().then(() => setStatus('Ready'));
    } else {
      setStatus('Not supported', true);
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
  
  window.addEventListener('beforeunload', () => {
    stopTicker();
    window.speechSynthesis.cancel();
  });
})();
</script>

<style>
.tts-button { transition: background 0.2s ease, transform 0.1s ease; border: none; outline: none; }
.tts-button:hover { filter: brightness(110%); }
.tts-button:active { transform: translateY(1px); }
@media (prefers-color-scheme: dark) {
  .tts-container { border-bottom-color: #333 !important; }
  #tts-status { color: #999 !important; }
}
</style>